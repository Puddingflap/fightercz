<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CZ Brawl</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin: 0; height: 100%; background: #0c1217; color: #e6f0ff; font: 14px ui-monospace, monospace; overflow: hidden; }
  #wrap { position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; }
  canvas { background: #000; image-rendering: pixelated; image-rendering: crisp-edges; outline: none; box-shadow: 0 8px 40px rgba(0,0,0,.55); }
  .hint { position: absolute; bottom: 10px; left: 0; right: 0; text-align: center; opacity: .85; pointer-events: none; }
  #touch-controls { position: absolute; bottom: 20px; left: 0; right: 0; display: none; justify-content: space-between; padding: 0 20px; z-index: 10; }
  #touch-controls button { width: 60px; height: 60px; border: 1px solid rgba(255,255,255,0.3); background: rgba(0,0,0,0.5); color: #fff; font-size: 24px; border-radius: 50%; touch-action: manipulation; }
  #dpad { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 5px; }
  #dpad button:nth-child(2) { grid-column: 2; grid-row: 1; } /* Up */
  #dpad button:nth-child(4) { grid-column: 1; grid-row: 2; } /* Left */
  #dpad button:nth-child(5) { grid-column: 3; grid-row: 2; } /* Right */
  #dpad button:nth-child(8) { grid-column: 2; grid-row: 3; } /* Down */
  #actions { display: flex; flex-direction: column; justify-content: space-between; height: 200px; }
  @media (max-width: 767px) { #touch-controls { display: flex; } }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="540" tabindex="0"></canvas>
  <div class="hint"></div>
  <audio id="titleMusic" src="assets/audio/title_theme.mp3" preload="auto" loop></audio>
</div>

<div id="touch-controls">
  <div id="dpad">
    <button data-key="ArrowUp">▲</button>
    <button data-key="ArrowLeft">◀</button>
    <button data-key="ArrowRight">▶</button>
    <button data-key="ArrowDown">▼</button>
  </div>
  <div id="actions">
    <button data-key="Space">Punch</button>
    <button data-key="ControlLeft">Kick</button>
    <button data-key="ShiftLeft">Power</button>
  </div>
</div>

<script>
const W = 960, H = 540;
const cvs = document.getElementById('game'), ctx = cvs.getContext('2d', { alpha: false });
ctx.imageSmoothingEnabled = false;
function fit() { const s = Math.min(innerWidth / W, innerHeight / H); cvs.style.width = (W * s) + 'px'; cvs.style.height = (H * s) + 'px'; }
addEventListener('resize', fit); fit();
const hintEl = document.querySelector('.hint');

function loadImage(src) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => { console.warn(`Failed to load ${src}`); resolve(null); };
    img.src = src;
  });
}
function drawBG(img, top = '#17202a', bot = '#0c1217') { if (img) ctx.drawImage(img, 0, 0, W, H); else { const g = ctx.createLinearGradient(0, 0, 0, H); g.addColorStop(0, top); g.addColorStop(1, bot); ctx.fillStyle = g; ctx.fillRect(0, 0, W, H); } }
function clearKeys() { keys.clear(); }
function sfxBeep(f = 880, d = .07) { try { const a = new (window.AudioContext || window.webkitAudioContext)(), o = a.createOscillator(), g = a.createGain(); o.frequency.value = f; o.type = 'square'; o.connect(g); g.connect(a.destination); g.gain.value = .06; o.start(); setTimeout(() => { o.stop(); a.close(); }, d * 1e3); } catch (e) { console.error('Audio failed:', e); } }

const UI = { logo: 'assets/ui/logo.png', titleBG: 'assets/ui/title_bg.jpg', selectBG: 'assets/ui/select_bg.jpg', portraits: 'assets/ui/portraits/', thumbs: 'assets/ui/thumbs/', mascot: 'assets/ui/mascot.png' };
const STAGE = 'assets/stages/market.png';
// --- HIER IS TRUMP TOEGEVOEGD ---
const ROSTER = [ { key: 'cz', name: 'CZ' }, { key: 'dusty', name: 'Dusty' }, { key: 'four', name: 'Four' }, { key: 'drshin', name: 'Dr. Shin', folder: 'dr.shin' }, { key: 'jeffcry', name: 'Jeffcry' }, { key: 'trump', name: 'Trump' }, { key: null }, { key: null }, { key: null }, { key: null }, ];
const COLORS = { p1: '#ffd54a', p2: '#4aa3ff', ready: '#6ee7a8', ui: '#e6f0ff' };

let STATE = 'LOADING';
let assets = { logo: null, titleBG: null, selectBG: null, mascot: null, stage: null };
let thumbsCache = {}, portraitsCache = {};
let mode = '1P';
let select = { p1Index: 0, p2Index: 1, p1Locked: false, p2Locked: false };
let versusTimer = 0, fightReady = false, pendingFight = null, fightLoadPromise = null;
let cooldown = 0;
const keys = new Set();
addEventListener('keydown', e => { if (!['F5', 'F12'].includes(e.code)) e.preventDefault(); keys.add(e.code); });
addEventListener('keyup', e => keys.delete(e.code));
cvs.addEventListener('click', () => { if (STATE === 'TITLE' && cooldown === 0) { userInteracted = true; startTitleMusic(); STATE = 'MODE'; sfxBeep(); cooldown = 10; } });

const touchButtons = document.querySelectorAll('#touch-controls button');
touchButtons.forEach(btn => {
  btn.addEventListener('touchstart', e => { e.preventDefault(); keys.add(btn.dataset.key); });
  btn.addEventListener('touchend', e => { e.preventDefault(); keys.delete(btn.dataset.key); });
});

const titleMusic = document.getElementById('titleMusic');
titleMusic.volume = 0.35;
let userInteracted = false;
function startTitleMusic() { if (!userInteracted) return; if (titleMusic.paused) { titleMusic.play().catch(() => {}); } }
function fadeAudio(audio, to = 0, ms = 400) { const from = audio.volume, steps = Math.max(1, Math.floor(ms / 16)); let i = 0; (function tick() { i++; audio.volume = from + (to - from) * (i / steps); if (i < steps) requestAnimationFrame(tick); else if (to === 0) { audio.pause(); audio.currentTime = 0; audio.volume = from; } })(); }
function stopTitleMusic() { if (!titleMusic.paused) fadeAudio(titleMusic, 0, 350); }
addEventListener('keydown', e => { if (STATE === 'TITLE' && !userInteracted && (e.code === 'Enter' || e.code === 'Space')) { userInteracted = true; startTitleMusic(); } if (e.code === 'KeyM') { titleMusic.muted = !titleMusic.muted; } });


// --- AANGEPAST LAADPROCES ---
async function tryLoadPaths(paths) {
    for (const path of paths) {
        const img = await loadImage(path);
        if (img) return img;
    }
    return null;
}

function getFolderForKey(key) {
  const e = ROSTER.find(r => r?.key === key);
  const base = (e && e.folder) ? e.folder : key;
  const variants = [base];
  if (base.includes('.')) variants.push(base.replace(/\./g, '')); else variants.push(base.replace(/_/g, '.'));
  variants.push(key);
  return [...new Set(variants)];
}

async function preloadCharacterUI(character) {
    if (!character || !character.key) return;
    const key = character.key;
    const folders = getFolderForKey(key);
    let thumbImg = null;
    for (const folder of folders) {
        // Probeert EERST de _idle1.png te laden (belangrijk voor thumbnails)
        thumbImg = await tryLoadPaths([ `assets/chars/${folder}/${key}_idle.png`, `assets/chars/${folder}/${key}_idle1.png` ]);
        if (thumbImg) break;
    }
    // Oude fallback (niet echt meer nodig met spritesheets, maar kan geen kwaad)
    if (!thumbImg) { thumbImg = await loadImage(`${UI.thumbs}${key}.png`); }
    if (thumbImg) { thumbsCache[key] = thumbImg; }

    // Laad het portret
    const portraitImg = await loadImage(`${UI.portraits}${key}.png`);
    if (portraitImg) { portraitsCache[key] = portraitImg; }
    // Fallback: Als er geen portret is, gebruik de idle thumb
    else if (thumbImg) { portraitsCache[key] = thumbImg; }
}


async function preloadAll() {
  const coreAssetPromises = [
    loadImage(UI.logo).then(img => assets.logo = img),
    loadImage(UI.titleBG).then(img => assets.titleBG = img),
    loadImage(UI.selectBG).then(img => assets.selectBG = img),
    loadImage(UI.mascot).then(img => assets.mascot = img),
    loadImage(STAGE).then(img => assets.stage = img)
  ];
  // Laadt nu UI (thumbnails en portraits) voor ALLE personages in de ROSTER
  const characterAssetPromises = ROSTER.filter(r => r?.key).map(r => preloadCharacterUI(r));
  await Promise.all([...coreAssetPromises, ...characterAssetPromises]);
}

(async function boot() {
  try {
    await preloadAll();
    STATE = 'TITLE';
  } catch (e) { console.error('Boot failed:', e); STATE = 'TITLE'; }
  loop();
})();

function stepLOADING() {
  drawBG(null);
  ctx.fillStyle = '#fff'; ctx.font = '24px ui-monospace,monospace'; ctx.textAlign = 'center';
  ctx.fillText('LOADING ASSETS...', W / 2, H / 2);
}

function stepTITLE() {
  drawBG(assets.titleBG);
  const L = assets.logo;
  if (L) {
    const maxW = W * 0.68, maxH = H * 0.50;
    const scale = Math.min(1, Math.min(maxW / L.width, maxH / L.height));
    const w = L.width * scale, h = L.height * scale;
    const x = (W - w) / 2, y = H * 0.06;
    ctx.drawImage(L, x, y, w, h);
    const t = (Math.sin(performance.now() / 700) + 1) / 2;
    ctx.fillStyle = `rgba(230,240,255,${0.45 + 0.45 * t})`;
    ctx.font = '20px ui-monospace,monospace'; ctx.textAlign = 'center';
    ctx.fillText('PRESS ENTER / CLICK TO START', W / 2, y + h + 30);
  } else {
    ctx.fillStyle = '#fff'; ctx.font = '48px ui-monospace,monospace'; ctx.textAlign = 'center';
    ctx.fillText('CZ BRAWL', W / 2, H * 0.25);
    ctx.font = '20px ui-monospace,monospace';
    ctx.fillText('PRESS ENTER / CLICK TO START', W / 2, H * 0.48);
  }
  ctx.fillStyle = '#9fb3ff'; ctx.font = '14px ui-monospace,monospace'; ctx.textAlign = 'center';
  ctx.fillText('$ASTER $OID STUDIOS 2025', W / 2, H - 18);
  startTitleMusic();
  if (cooldown > 0) { cooldown--; return; }
  if (keys.has('Enter') || keys.has('Space')) { userInteracted = true; startTitleMusic(); STATE = 'MODE'; sfxBeep(); clearKeys(); cooldown = 10; }
}
function stepMODE() {
  drawBG(assets.titleBG);
  ctx.fillStyle = '#fff'; ctx.font = '26px ui-monospace,monospace'; ctx.textAlign = 'center';
  ctx.fillText('SELECT MODE', W / 2, 90);
  const options = [{ label: 'P1 vs CPU', val: '1P' }, { label: 'P1 vs P2', val: '2P' }];
  const boxW = 260, boxH = 70, gap = 24, startY = H / 2 - (boxH * options.length + gap * (options.length - 1)) / 2;
  for (let i = 0; i < options.length; i++) {
    const x = W / 2 - boxW / 2, y = startY + i * (boxH + gap), active = (mode === options[i].val);
    ctx.fillStyle = active ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.28)'; ctx.fillRect(x, y, boxW, boxH);
    ctx.strokeStyle = active ? COLORS.p1 : 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2; ctx.strokeRect(x + 1, y + 1, boxW - 2, boxH - 2);
    ctx.fillStyle = '#e6f0ff'; ctx.font = '22px ui-monospace,monospace'; ctx.fillText(options[i].label, x + boxW / 2, y + boxH / 2 + 7);
  }
  startTitleMusic();
  if (cooldown > 0) { cooldown--; return; }
  if (keys.has('ArrowUp') || keys.has('KeyW')) { mode = (mode === '2P' ? '1P' : '2P'); keys.delete('ArrowUp'); keys.delete('KeyW'); sfxBeep(700); }
  if (keys.has('ArrowDown') || keys.has('KeyS')) { mode = (mode === '1P' ? '2P' : '1P'); keys.delete('ArrowDown'); keys.delete('KeyS'); sfxBeep(700); }
  if (keys.has('Enter') || keys.has('Space')) { STATE = 'SELECT'; clearKeys(); sfxBeep(900); cooldown = 8; }
  if (keys.has('Escape')) { STATE = 'TITLE'; clearKeys(); sfxBeep(500); cooldown = 8; }
}

const grid = { cols: 5, rows: 2, cellW: 120, cellH: 120, startX: (W - 5 * 120) / 2, startY: 180 };

function drawThumbCell(ix, iy, img, locked = false, isReady = false, readyTag = '') {
  const x = grid.startX + ix * grid.cellW, y = grid.startY + iy * grid.cellH, w = grid.cellW - 8, h = grid.cellH - 8;
  ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
  if (img) {
      // Probeer de afbeelding gecentreerd en geschaald te tekenen
      const aspectRatio = img.width / img.height;
      let drawW = w - 32; // Padding van 16px aan elke kant
      let drawH = drawW / aspectRatio;
      if (drawH > h - 32) {
          drawH = h - 32;
          drawW = drawH * aspectRatio;
      }
      const drawX = x + (w - drawW) / 2;
      const drawY = y + (h - drawH) / 2;
      ctx.drawImage(img, drawX, drawY, drawW, drawH);
  }
  if (locked) {
    ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#aaa'; ctx.font = '12px ui-monospace,monospace'; ctx.textAlign = 'center';
    ctx.fillText('COMING', x + w / 2, y + h / 2 - 6); ctx.fillText('SOON', x + w / 2, y + h / 2 + 10);
  }
  if (isReady) {
    ctx.strokeStyle = COLORS.ready; ctx.lineWidth = 3; ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
    ctx.fillStyle = 'rgba(110,231,168,0.15)'; ctx.fillRect(x, y, w, h);
    ctx.fillStyle = COLORS.ready; ctx.font = '11px ui-monospace,monospace'; ctx.textAlign = 'right';
    ctx.fillText(readyTag, x + w - 6, y + 16);
  }
}

function stepSELECT() {
  drawBG(assets.selectBG);
  startTitleMusic();
  const lk = ROSTER[select.p1Index].key, rk = ROSTER[select.p2Index].key;
  
  const leftPortrait = portraitsCache[lk];
  const rightPortrait = portraitsCache[rk];
  
  const pSize = 260;
  if (leftPortrait) { ctx.drawImage(leftPortrait, 60, 120, pSize, pSize); }
  if (rightPortrait) { ctx.drawImage(rightPortrait, W - 60 - pSize, 120, pSize, pSize); }

  ctx.fillStyle = COLORS.p1; ctx.font = '18px ui-monospace,monospace'; ctx.textAlign = 'left'; ctx.fillText('1P', 60, 120 + pSize + 22);
  ctx.fillStyle = COLORS.p2; ctx.textAlign = 'right'; ctx.fillText('2P', W - 60, 120 + pSize + 22);
  for (let r = 0; r < grid.rows; r++) for (let c = 0; c < grid.cols; c++) {
    const idx = r * grid.cols + c, cell = ROSTER[idx], locked = !cell?.key;
    const isReadyP1 = select.p1Locked && idx === select.p1Index;
    const isReadyP2 = mode === '2P' && select.p2Locked && idx === select.p2Index;
    const thumbImg = cell?.key ? thumbsCache[cell.key] : null;
    drawThumbCell(c, r, thumbImg, locked, isReadyP1 || isReadyP2, (isReadyP1 ? '1P ' : '') + (isReadyP2 ? '2P' : ''));
  }
  const cur = (i, col, tag) => {
    const ix = i % grid.cols, iy = Math.floor(i / grid.cols), x = grid.startX + ix * grid.cellW, y = grid.startY + iy * grid.cellH;
    ctx.strokeStyle = col; ctx.lineWidth = 3; ctx.strokeRect(x + 2, y + 2, grid.cellW - 12, grid.cellH - 12);
    ctx.fillStyle = col; ctx.font = '12px ui-monospace,monospace'; ctx.textAlign = 'left';
    ctx.fillText(tag, x + 6, y + 16);
  };
  if (!select.p1Locked) cur(select.p1Index, COLORS.p1, '1P');
  if (mode === '2P' && !select.p2Locked) cur(select.p2Index, COLORS.p2, '2P');
  const nameAt = i => ROSTER[i]?.key ? ROSTER[i].name : '—'; // Veiligere check
  ctx.fillStyle = '#e6f0ff'; ctx.font = '18px ui-monospace,monospace'; ctx.textAlign = 'center';
  ctx.fillText(nameAt(select.p1Index), W * 0.25, H - 40);
  ctx.fillText(nameAt(select.p2Index), W * 0.75, H - 40);
  if (cooldown > 0) { cooldown--; return; }
  const move = (who, dx, dy) => {
    const cols = grid.cols, rows = grid.rows;
    let i = (who === 'p1' ? select.p1Index : select.p2Index), x = i % cols, y = Math.floor(i / cols);
    do { 
        x = (x + dx + cols) % cols; // Wrap around horizontaal
        y = (y + dy + rows) % rows; // Wrap around verticaal
        i = y * cols + x; 
    } while (ROSTER[i] && !ROSTER[i].key && (dx !== 0 || dy !== 0)); // Blijf zoeken als het een leeg slot is

    if (ROSTER[i] && ROSTER[i].key) { // Check opnieuw of we een geldig slot hebben gevonden
        if (who === 'p1') select.p1Index = i; else select.p2Index = i; sfxBeep(700); 
    }
  };
  if (!select.p1Locked) {
    if (keys.has('ArrowLeft')) { move('p1', -1, 0); keys.delete('ArrowLeft'); cooldown = 5;} // Cooldown toegevoegd
    if (keys.has('ArrowRight')) { move('p1', 1, 0); keys.delete('ArrowRight'); cooldown = 5;}
    if (keys.has('ArrowUp')) { move('p1', 0, -1); keys.delete('ArrowUp'); cooldown = 5;}
    if (keys.has('ArrowDown')) { move('p1', 0, 1); keys.delete('ArrowDown'); cooldown = 5;}
    if (keys.has('Enter') || keys.has('Space')) { if (ROSTER[select.p1Index]?.key) { select.p1Locked = true; sfxBeep(900); } keys.delete('Enter'); keys.delete('Space'); }
  }
  if (mode === '2P' && !select.p2Locked) {
    if (keys.has('KeyA')) { move('p2', -1, 0); keys.delete('KeyA'); cooldown = 5;}
    if (keys.has('KeyD')) { move('p2', 1, 0); keys.delete('KeyD'); cooldown = 5;}
    if (keys.has('KeyW')) { move('p2', 0, -1); keys.delete('KeyW'); cooldown = 5;}
    if (keys.has('KeyS')) { move('p2', 0, 1); keys.delete('KeyS'); cooldown = 5;}
    if (keys.has('KeyF') || keys.has('KeyG')) { if (ROSTER[select.p2Index]?.key) { select.p2Locked = true; sfxBeep(900); } keys.delete('KeyF'); keys.delete('KeyG'); }
  }
  if (mode === '1P' && select.p1Locked && !select.p2Locked) {
    const choices = ROSTER.map((c, i) => ({ c, i })).filter(o => o.c?.key && o.i !== select.p1Index);
    if (choices.length) { const pick = choices[Math.floor(Math.random() * choices.length)]; select.p2Index = pick.i; }
    select.p2Locked = true;
  }
  if (select.p1Locked && select.p2Locked) {
    STATE = 'VERSUS'; versusTimer = 0; fightReady = false; pendingFight = null; clearKeys(); cooldown = 8;
  }
  if (keys.has('Escape')) { STATE = 'MODE'; select = { p1Index: 0, p2Index: 1, p1Locked: false, p2Locked: false }; clearKeys(); sfxBeep(500); cooldown = 8; }
}
function stepVERSUS() {
  drawBG(null); ctx.fillStyle = '#10151b'; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = '#fff'; ctx.font = '24px ui-monospace,monospace'; ctx.textAlign = 'center'; ctx.fillText('VERSUS', W / 2, 56);
  const left = ROSTER[select.p1Index], right = ROSTER[select.p2Index];
  const drawSide = (slot, x) => {
    const p = portraitsCache[slot.key];
    const yPos = GROUND_Y - 64 * SPRITE_SCALE + 50;
    const hSize = 64 * SPRITE_SCALE;
    if (p) { 
        const s = Math.min(1, 240 / Math.max(p.width, p.height)); 
        const w = p.width * s, h = p.height * s; 
        ctx.drawImage(p, x - w / 2, yPos - h / 2, w, h); 
    }
    ctx.fillStyle = '#e6f0ff'; ctx.font = '20px ui-monospace,monospace'; 
    ctx.fillText(slot.name || slot.key, x, yPos + hSize / 2 + 20);
  };
  drawSide(left, W * 0.25);
  drawSide(right, W * 0.75);
  ctx.fillStyle = COLORS.p1; ctx.font = '16px ui-monospace,monospace'; ctx.fillText('1P', W * 0.25, 86);
  ctx.fillStyle = COLORS.p2; ctx.fillText('2P', W * 0.75, 86);
  ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.font = '14px ui-monospace,monospace'; ctx.fillText(fightReady ? 'READY!' : 'Loading…', W / 2, H - 24);
  startTitleMusic();
  if (!fightLoadPromise) {
    const L = ROSTER[select.p1Index], R = ROSTER[select.p2Index];
    fightLoadPromise = startFight(L, R, mode)
      .then(() => { fightReady = true; })
      .catch(e => { console.error('Fight load failed:', e); fightReady = true; });
  }
  versusTimer++;
  if (versusTimer > 60 && fightReady) { STATE = 'FIGHT'; stopTitleMusic(); clearKeys(); cooldown = 8; fightLoadPromise = null; }
}

const GRAV = 0.75, FRICTION = 0.85, SPRITE_SCALE = 2.25, GROUND_Y = 530;
const ENERGY_MAX = 100, ENERGY_HIT_GAIN = 12, ENERGY_GOT_HIT_GAIN = 6, ENERGY_PASSIVE_PER_FRAME = 0.5 / 60, ENERGY_POWER_COST = 40, ENERGY_CHARGE_PER_FRAME = 20 / 60;
const DAMAGE_NORMAL = 6, DAMAGE_POWER = 10;
let fight = { p1: null, p2: null, stage: null, freeze: 0, paused: false, round: 1, w1: 0, w2: 0, phase: 'intro', phaseTimer: 0, roundSettled: false, matchOver: false }, impacts = [];

function addImpact(x, y, t = 'yellow') { if (impacts.length > 18) impacts.shift(); impacts.push({ x, y, life: 4, tint: t }); }
function drawImpacts() { for (const p of impacts) { const t = p.life / 4, col = p.tint === 'blue' ? `rgba(120,200,255,${0.55 * t})` : `rgba(255,235,160,${0.55 * t})`; ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.beginPath(); ctx.arc(p.x, p.y, 5 * (1 - t) + 2, 0, Math.PI * 2); ctx.fillStyle = col; ctx.fill(); ctx.restore(); } }
function updateImpacts() { impacts = impacts.filter(p => (--p.life) > 0); }
function drawBars(p1, p2) {
  const pad = 10, barW = (W / 2) - 100, y = 12, BH = 10, G = 6;
  ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fillRect(0, 0, W, 64);
  const s1 = Math.max(0, Math.min(2, fight.w1)), s2 = Math.max(0, Math.min(2, fight.w2));
  ctx.fillStyle = '#e6f0ff'; ctx.font = '15px ui-monospace,monospace'; ctx.textAlign = 'center'; ctx.fillText(`SCORE  ${s1}–${s2}   ·   R${fight.round}`, W / 2, y + 10);
  if (assets.mascot) { const mw = 32, mh = 32; ctx.drawImage(assets.mascot, W / 2 - mw / 2, y + 16, mw, mh); }
  const bar = (x, v) => { ctx.fillStyle = '#fff'; ctx.fillRect(x, y + 30, barW, BH); ctx.fillStyle = '#222'; ctx.fillRect(x + 2, y + 32, barW - 4, BH - 4); ctx.fillStyle = '#e04f3f'; ctx.fillRect(x + 2, y + 32, (barW - 4) * Math.max(0, Math.min(1, v / 100)), BH - 4); };
  const barR = (x, v) => { ctx.fillStyle = '#fff'; ctx.fillRect(x, y + 30, barW, BH); ctx.fillStyle = '#222'; ctx.fillRect(x + 2, y + 32, barW - 4, BH - 4); ctx.fillStyle = '#e04f3f'; const w = (barW - 4) * Math.max(0, Math.min(1, v / 100)); ctx.fillRect(x + (barW - 2) - w, y + 32, w, BH - 4); };
  bar(pad, p1.hp); barR(W - pad - barW, p2.hp);
  const pow = (x, val, rtl = false) => { ctx.fillStyle = '#fff'; ctx.fillRect(x, y + 30 + BH + G, barW, BH); ctx.fillStyle = '#222'; ctx.fillRect(x + 2, y + 32 + BH + G, barW - 4, BH - 4); ctx.fillStyle = '#4aa3ff'; const w = (barW - 4) * Math.max(0, Math.min(1, val / ENERGY_MAX)); if (!rtl) ctx.fillRect(x + 2, y + 32 + BH + G, w, BH - 4); else ctx.fillRect(x + (barW - 2) - w, y + 32 + BH + G, w, BH - 4); ctx.save(); ctx.font = '10px ui-monospace,monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = 'rgba(0,0,0,.75)'; ctx.fillText('POWER', x + barW / 2 + 1, y + 32 + BH + G + BH / 2 + 1); ctx.fillStyle = '#e6f0ff'; ctx.fillText('POWER', x + barW / 2, y + 32 + BH + G + BH / 2); ctx.restore(); }
  pow(pad, p1.energy, false); pow(W - pad - barW, p2.energy, true);
}
function rectsOverlap(a, b) { return a && b && a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

// --- NIEUWE FUNCTIES VOOR SPRITESHEETS ---
async function loadFighterSprites_Legacy(entry) {
    console.log(`Laden van ${entry.key} via oude methode...`);
    const key = entry.key, folders = getFolderForKey(key);
    const states = ['idle', 'walk', 'run', 'punch', 'kick', 'kneel', 'kp', 'kk', 'power', 'ko'];
    const anim = { isSpritesheet: false };

    async function loadAnim(animFolders, animKey, state) {
        async function any(base) { const exts = ['.png', '.PNG', '.webp']; for (const e of exts) { const im = await loadImage(base + e); if (im) return im; } return null; }
        const frames = [];
        for (const folder of animFolders) { const exact = await any(`assets/chars/${folder}/${animKey}_${state}`); if (exact) { frames.push(exact); break; } }
        for (const folder of animFolders) { for (let n = 1; n <= 8; n++) { const fr = await any(`assets/chars/${folder}/${animKey}_${state}${n}`); if (fr) frames.push(fr); } if (frames.length) break; }
        return frames.length ? frames : null;
    }

    const animPromises = states.map(s => loadAnim(folders, key, s));
    const animResults = await Promise.all(animPromises);

    let fallback = animResults[0] || [await loadImage('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==')];

    states.forEach((s, i) => anim[s] = animResults[i] || fallback);
    return anim;
}

async function loadFighterSprites(entry) {
    const key = entry.key;
    const folder = getFolderForKey(key)[0];
    const basePath = `assets/chars/${folder}/${key}_spritesheet`;

    try {
        const jsonResponse = await fetch(`${basePath}.json`);
        if (!jsonResponse.ok) throw new Error('JSON niet gevonden');

        const [data, sheetImage] = await Promise.all([
            jsonResponse.json(),
            loadImage(`${basePath}.png`)
        ]);

        if (!sheetImage) throw new Error('Spritesheet afbeelding niet gevonden');
        
        console.log(`Laden van ${key} via NIEUWE spritesheet methode...`);
        const states = { idle: [], walk: [], run: [], punch: [], kick: [], kneel: [], kp: [], kk: [], power: [], ko: [] };
        for (const frameName in data.frames) {
            // Haalt 'idle', 'punch' etc. uit 'cz_idle1.png'
            const match = frameName.match(/_([a-zA-Z]+)/);
            if (match && match[1]) {
                const stateName = match[1].replace(/[0-9]/g, ''); // Verwijder cijfers
                if (states[stateName] !== undefined) { // Check of de state bestaat
                    states[stateName].push(frameName);
                } else {
                    console.warn(`Onbekende animatiestaat gevonden in JSON voor ${key}: ${stateName} (van ${frameName})`);
                }
            }
        }
        
        for(const state in states) {
            states[state].sort();
            // Fallback voor animaties die niet in de spritesheet zitten (gebruik idle)
            if (states[state].length === 0 && states.idle.length > 0) {
                 console.warn(`Animatie ${state} voor ${key} niet gevonden in spritesheet, gebruik idle als fallback.`);
                 states[state] = states.idle;
            } else if (states[state].length === 0) {
                 console.error(`GEEN frames gevonden voor ${state} EN geen idle fallback voor ${key}!`);
                 // Voeg een placeholder toe om crashes te voorkomen
                 states[state] = ['placeholder_frame_name'];
                 if (!data.frames['placeholder_frame_name']) {
                     // Maak een minimale placeholder entry als die niet bestaat
                     data.frames['placeholder_frame_name'] = { frame: { x: 0, y: 0, w: 1, h: 1 } };
                 }
            }
        }

        return { isSpritesheet: true, sheet: sheetImage, data: data.frames, states };

    } catch (error) {
        console.warn(`Spritesheet voor ${key} niet gevonden of fout bij laden: ${error.message}. Terugvallen op oude methode.`);
        return loadFighterSprites_Legacy(entry);
    }
}


class Fighter {
  // --- AANGEPASTE FIGHTER CLASS ---
  constructor(name, spriteData, ctrl) {
    this.name = name;
    this.sprite = spriteData; // Bevat nu .sheet, .data, en .states OF de oude animaties
    this.ctrl = ctrl;
    
    this.w = 64 * SPRITE_SCALE; this.h = 64 * SPRITE_SCALE;
    this.x = W / 2 - this.w / 2; this.y = GROUND_Y - this.h + 50;
    this.vx = 0; this.vy = 0; this.onGround = true;
    this.state = 'idle'; this.frame = 0; this.timer = 0;
    this.facing = 1; this.hp = 100; this.energy = 0;
    this.hitstun = 0; this.attackTimer = 0; this.attackDidHit = false;
    this.attackActiveFrom = 0; this.attackActiveTo = 0;
    this.charging = false; this.chargePulse = 0;
  }
  resetRound(side) { this.hp = 100; this.energy = 0; this.vx = this.vy = 0; this.onGround = true; this.frame = 0; this.timer = 0; this.state = 'idle'; this.facing = side; this.attackTimer = 0; this.attackDidHit = false; this.hitstun = 0; this.charging = false; }
  play(s) { if (this.state !== s) { this.state = s; this.frame = 0; this.timer = 0; this.attackTimer = 0; this.attackDidHit = false; if (s === 'punch') { this.attackActiveFrom = 3; this.attackActiveTo = 6; } else if (s === 'kick') { this.attackActiveFrom = 4; this.attackActiveTo = 7; } else if (s === 'kp') { this.attackActiveFrom = 3; this.attackActiveTo = 6; } else if (s === 'kk') { this.attackActiveFrom = 4; this.attackActiveTo = 7; } else if (s === 'power') { this.attackActiveFrom = 2; this.attackActiveTo = 10; } else if (s === 'ko') { this.attackActiveFrom = 0; this.attackActiveTo = 0; } else { this.attackActiveFrom = 0; this.attackActiveTo = 0; } } }
  canAct() { return this.hitstun === 0 && !['punch', 'kick', 'kp', 'kk', 'power', 'ko'].includes(this.state); }
  addEnergy(v) { this.energy = Math.max(0, Math.min(ENERGY_MAX, this.energy + v)); }
  spendEnergy(v) { this.energy = Math.max(0, this.energy - v); }
  takeHit(d, dir) { if (this.hitstun > 0 || this.state === 'ko') return; this.hp = Math.max(0, this.hp - d); this.hitstun = 10; this.vx += dir * 1.8; this.addEnergy(ENERGY_GOT_HIT_GAIN); if (this.hp <= 0) this.play('ko'); }
  getHurtbox() { if (this.state === 'ko') return null; return { x: this.x + this.w * 0.31, y: this.y + this.h * 0.12, w: this.w * 0.38, h: this.h * 0.80 }; }
  getAttackHitbox() {
    if (!['punch', 'kick', 'kp', 'kk', 'power'].includes(this.state)) return null;
    if (this.attackTimer < this.attackActiveFrom || this.attackTimer > this.attackActiveTo || this.attackDidHit) return null;
    const d = this.facing;
    if (this.state === 'punch') { const w = this.w * 0.30, h = this.h * 0.24; const x = d === 1 ? this.x + this.w * 0.68 : this.x - w + this.w * 0.32; const y = this.y + this.h * 0.40 - h * 0.6; return { x, y, w, h, dir: d }; }
    if (this.state === 'kick') { const w = this.w * 0.34, h = this.h * 0.22; const x = d === 1 ? this.x + this.w * 0.66 : this.x - w + this.w * 0.34; const y = this.y + this.h * 0.56; return { x, y, w, h, dir: d }; }
    if (this.state === 'kp') { const w = this.w * 0.28, h = this.h * 0.18; const x = d === 1 ? this.x + this.w * 0.62 : this.x - w + this.w * 0.38; const y = this.y + this.h * 0.66; return { x, y, w, h, dir: d }; }
    if (this.state === 'kk') { const w = this.w * 0.34, h = this.h * 0.16; const x = d === 1 ? this.x + this.w * 0.62 : this.x - w + this.w * 0.38; const y = this.y + this.h * 0.70; return { x, y, w, h, dir: d }; }
    if (this.state === 'power') { const len = this.w * 0.90, h = this.h * 0.26; const x = d === 1 ? this.x + this.w * 0.56 : this.x - len * 0.56; const y = this.y + this.h * 0.40 - h * 0.5; return { x, y, w: len, h, dir: d, blue: true }; }
    return null;
  }
  updateControls() {
    if (this.ctrl === 'CPU') return this.updateAI(fight.p1);
    const P1 = (this.ctrl === 'P1');
    const L = keys.has(P1 ? 'ArrowLeft' : 'KeyA'), R = keys.has(P1 ? 'ArrowRight' : 'KeyD'), U = keys.has(P1 ? 'ArrowUp' : 'KeyW'),
          D = keys.has(P1 ? 'ArrowDown' : 'KeyS'), P = keys.has(P1 ? 'Space' : 'KeyF'), K = keys.has(P1 ? 'ControlLeft' : 'KeyG'),
          POW = keys.has(P1 ? 'ShiftLeft' : 'AltLeft');
    if (this.state === 'ko') { this.vx *= 0.9; return; }
    if (this.hitstun > 0) { this.vx *= 0.9; this.hitstun--; this.charging = false; return; }
    if (POW && this.canAct()) { this.charging = true; this.addEnergy(ENERGY_CHARGE_PER_FRAME); if (D) this.play('kneel'); else if (Math.abs(this.vx) < 0.2) this.play('idle'); }
    else if (this.charging) { this.charging = false; if (this.energy >= ENERGY_POWER_COST) { this.play('power'); this.spendEnergy(ENERGY_POWER_COST); return; } }
    if (L && !R) { this.vx = -2.4; this.facing = -1; } else if (R && !L) { this.vx = 2.4; this.facing = 1; } else this.vx *= FRICTION;
    if (U && this.onGround) { this.vy = -11; this.onGround = false; }
    if (D && this.canAct()) { if (P) { this.play('kp'); return; } if (K) { this.play('kk'); return; } this.play('kneel'); }
    else if (this.canAct()) { if (P) { this.play('punch'); return; } if (K) { this.play('kick'); return; } if (Math.abs(this.vx) > 0.4 && this.onGround) this.play('walk'); else this.play('idle'); }
  }
  updateAI(target) {
    if (this.state === 'ko') { this.vx *= 0.9; return; }
    const dx = (target.x + target.w / 2) - (this.x + this.w / 2), dist = Math.abs(dx);
    this.facing = dx > 0 ? 1 : -1;
    if (this.hitstun > 0) { this.vx *= 0.9; this.hitstun--; this.charging = false; return; }
    const close = this.w * 0.75, mid = this.w * 1.6;
    if (dist > mid) { this.charging = false; this.vx = dx > 0 ? 2.2 : -2.2; if (this.canAct()) this.play('walk'); }
    else if (dist > close) {
      if (this.energy >= ENERGY_POWER_COST && Math.random() < 0.01 && this.canAct()) { this.play('power'); this.spendEnergy(ENERGY_POWER_COST); return; }
      this.vx = dx > 0 ? 1.6 : -1.6; if (this.canAct()) this.play('walk');
      if (Math.random() < 0.02 && this.onGround) { this.vy = -8; this.onGround = false; }
    } else {
      this.vx *= FRICTION;
      if (this.canAct()) { const low = Math.random() < 0.5; this.play(low ? (Math.random() < 0.5 ? 'kp' : 'kk') : (Math.random() < 0.5 ? 'punch' : 'kick')); }
    }
  }
  physics() { this.vy += GRAV; this.x += this.vx; this.y += this.vy; if (this.y + this.h >= GROUND_Y) { this.y = GROUND_Y - this.h; this.vy = 0; this.onGround = true; } this.x = Math.max(20, Math.min(W - 20 - this.w, this.x)); }
  
  animStep() {
    const spd = { idle: 8, walk: 10, run: 12, kneel: 1, punch: 12, kick: 12, kp: 12, kk: 12, power: 14, ko: 6 };
    // Bepaal welke lijst met frames we moeten gebruiken (spritesheet of oude methode)
    const animFrames = this.sprite.isSpritesheet ? (this.sprite.states[this.state] || this.sprite.states.idle) : (this.sprite[this.state] || this.sprite.idle);
    
    // Check of er wel frames zijn voor deze animatie
    if (!animFrames || animFrames.length === 0 || animFrames[0] === 'placeholder_frame_name') {
        console.warn(`Geen geldige frames gevonden voor state ${this.state} bij ${this.name}`);
        // Optioneel: speel idle af als fallback
        if (this.state !== 'idle') this.play('idle');
        return; 
    }

    const fps = (spd[this.state] || 8);
    this.timer += fps / 60;

    if (this.timer >= 1) {
        this.timer = 0;
        this.frame++;
        if (['punch', 'kick', 'kp', 'kk', 'power', 'ko'].includes(this.state)) this.attackTimer++;
    }
    if (this.frame >= animFrames.length) {
        if (['punch', 'kick', 'kp', 'kk', 'power', 'ko'].includes(this.state)) {
            this.frame = animFrames.length - 1;
            if (this.state !== 'ko') {
                this._hold = (this._hold || 0) + 1;
                if (this._hold > 6) { this._hold = 0; this.play('idle'); }
            }
        } else {
            this.frame = 0;
        }
    }
    this.addEnergy(ENERGY_PASSIVE_PER_FRAME);
    if (this.charging) this.chargePulse += 0.12; else this.chargePulse = 0;
  }
  
  draw() {
    if (this.charging) { const cx = this.x + this.w / 2, cy = this.y + this.h * 0.55, r = 18 + Math.sin(this.chargePulse) * 4; const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 3); g.addColorStop(0, 'rgba(100,180,255,0.35)'); g.addColorStop(1, 'rgba(100,180,255,0.0)'); ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r * 3, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
    
    ctx.save();
    if (this.facing === -1) {
        ctx.scale(-1, 1);
        ctx.translate(-this.x - this.w, this.y);
    } else {
        ctx.translate(this.x, this.y);
    }
    
    if (this.sprite.isSpritesheet) {
        // NIEUWE METHODE: Teken een stukje uit de spritesheet
        const animFrames = this.sprite.states[this.state] || this.sprite.states.idle;
        // Veiligheid check: Zorg dat frame index binnen de grenzen blijft
        const currentFrameIndex = Math.min(this.frame, animFrames.length - 1); 
        const currentFrameName = animFrames[currentFrameIndex];
        
        if (currentFrameName === 'placeholder_frame_name' && this.sprite.data['placeholder_frame_name']) {
             // Teken een rode box als placeholder
             ctx.fillStyle = 'red';
             ctx.fillRect(0, 0, this.w, this.h);
        } else {
            const frameData = this.sprite.data[currentFrameName];
            if (frameData) {
                const { x: sx, y: sy, w: sW, h: sH } = frameData.frame;
                ctx.drawImage(this.sprite.sheet, sx, sy, sW, sH, 0, 0, this.w, this.h);
            } else {
                 console.error(`Frame data niet gevonden voor ${currentFrameName} in state ${this.state} bij ${this.name}`);
                 // Optioneel: teken placeholder
                 ctx.fillStyle = 'purple';
                 ctx.fillRect(0, 0, this.w, this.h);
            }
        }
    } else {
        // OUDE METHODE: Teken een losse afbeelding
        const anim = this.sprite[this.state] || this.sprite.idle;
        // Veiligheid check
        const currentFrameIndex = Math.min(this.frame, anim.length - 1);
        const img = anim[currentFrameIndex];
        if (img) {
            ctx.drawImage(img, 0, 0, this.w, this.h);
        }
    }
    
    ctx.restore();
  }
}

async function startFight(entry1, entry2, mode) {
  const [a1, a2] = await Promise.all([loadFighterSprites(entry1), loadFighterSprites(entry2)]);
  fight.p1 = new Fighter(entry1.name || entry1.key, a1, 'P1');
  fight.p2 = new Fighter(entry2.name || entry2.key, a2, mode === '2P' ? 'P2' : 'CPU');
  fight.round = 1; fight.w1 = 0; fight.w2 = 0; fight.paused = false; fight.phase = 'intro'; fight.phaseTimer = 90;
  fight.roundSettled = false; fight.matchOver = false;
  resetPositions(); fight.freeze = 0; impacts = [];
}
function resetPositions() {
  fight.p1.resetRound(1);
  fight.p2.resetRound(-1);
  fight.p1.x = W * 0.30 - fight.p1.w / 2;
  fight.p2.x = W * 0.70 - fight.p2.w / 2;
  fight.p1.y = GROUND_Y - fight.p1.h + 0;
  fight.p2.y = GROUND_Y - fight.p2.h + 0;
}
function drawPause() {
  ctx.fillStyle = 'rgba(0,0,0,0.65)'; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = '#e6f0ff'; ctx.font = '32px ui-monospace,monospace'; ctx.textAlign = 'center';
  ctx.fillText('PAUSED', W / 2, H / 2 - 40);
  ctx.font = '16px ui-monospace,monospace';
  ctx.fillText('[P/ESC] Resume  ·  [R] Restart Round  ·  [Q] Quit to Select', W / 2, H / 2 + 4);
}
function togglePause() { fight.paused = !fight.paused; if (fight.paused) clearKeys(); }
function stepFIGHT() {
  drawBG(assets.stage);
  if (!fight.p1 || !fight.p2) { ctx.fillStyle = '#e6f0ff'; ctx.font = '16px ui-monospace,monospace'; ctx.textAlign = 'center'; ctx.fillText('Loading...', W / 2, H / 2); return; }
  if (keys.has('KeyP') || keys.has('Escape')) { togglePause(); keys.delete('KeyP'); keys.delete('Escape'); }
  if (fight.paused) {
    drawBars(fight.p1, fight.p2); fight.p1.draw(); fight.p2.draw(); drawPause();
    if (keys.has('Enter')) { togglePause(); keys.delete('Enter'); }
    if (keys.has('KeyR')) { resetPositions(); fight.paused = false; fight.roundSettled = false; clearKeys(); }
    if (keys.has('KeyQ')) { STATE = 'SELECT'; select.p1Locked = false; select.p2Locked = false; fight.paused = false; clearKeys(); cooldown = 8; }
    return;
  }
  if (fight.matchOver) {
    drawBars(fight.p1, fight.p2); fight.p1.draw(); fight.p2.draw();
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff'; ctx.font = '32px ui-monospace,monospace'; ctx.textAlign = 'center';
    ctx.fillText(fight.w1 > fight.w2 ? '1P WINS MATCH!' : '2P WINS MATCH!', W / 2, H / 2 - 10);
    ctx.font = '16px ui-monospace,monospace';
    ctx.fillText('ENTER: rematch · ESC: terug naar SELECT', W / 2, H / 2 + 26);
    if (keys.has('Enter')) { const e1 = ROSTER[select.p1Index], e2 = ROSTER[select.p2Index]; fightReady = false; fightLoadPromise = null; fight.p1 = null; fight.p2 = null; STATE = 'VERSUS'; clearKeys(); }
    if (keys.has('Escape')) { STATE = 'SELECT'; select.p1Locked = false; select.p2Locked = false; clearKeys(); cooldown = 8; }
    return;
  }
  if (fight.phase !== 'play') {
    drawBars(fight.p1, fight.p2); fight.p1.draw(); fight.p2.draw();
    ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#e6f0ff'; ctx.textAlign = 'center';
    if (fight.phase === 'intro') {
      ctx.font = '28px ui-monospace,monospace'; ctx.fillText(`ROUND ${fight.round}`, W / 2, H / 2 - 8);
      ctx.font = '18px ui-monospace,monospace'; ctx.fillText('FIGHT!', W / 2, H / 2 + 26);
    } else if (fight.phase === 'between') {
      ctx.font = '22px ui-monospace,monospace'; ctx.fillText('GET READY', W / 2, H / 2 + 6);
    }
    if (--fight.phaseTimer <= 0) { fight.phase = 'play'; fight.roundSettled = false; }
    return;
  }
  if (fight.freeze === 0) {
    fight.p1.updateControls(); if (fight.p2.ctrl === 'CPU') fight.p2.updateAI(fight.p1); else fight.p2.updateControls();
    fight.p1.physics(); fight.p2.physics(); fight.p1.animStep(); fight.p2.animStep();
    const hit = (att, def) => { const hb = att.getAttackHitbox(), db = def.getHurtbox(); if (hb && db && rectsOverlap(hb, db)) { const dmg = hb.blue ? DAMAGE_POWER : DAMAGE_NORMAL; def.takeHit(dmg, hb.dir); att.attackDidHit = true; att.addEnergy(ENERGY_HIT_GAIN); const cx = (Math.max(hb.x, db.x) + Math.min(hb.x + hb.w, db.x + db.w)) / 2, cy = (Math.max(hb.y, db.y) + Math.min(hb.y + hb.h, db.y + db.h)) / 2; addImpact(cx, cy, hb.blue ? 'blue' : 'yellow'); fight.freeze = 4; } };
    hit(fight.p1, fight.p2); hit(fight.p2, fight.p1);
  } else { fight.freeze--; }
  fight.p1.draw(); fight.p2.draw(); drawImpacts(); updateImpacts(); drawBars(fight.p1, fight.p2);
  const p1Dead = (fight.p1.state === 'ko'), p2Dead = (fight.p2.state === 'ko');
  if (!fight.roundSettled && (p1Dead || p2Dead)) {
    fight.roundSettled = true;
    if (p1Dead && !p2Dead) fight.w2 = Math.min(2, fight.w2 + 1);
    else if (p2Dead && !p1Dead) fight.w1 = Math.min(2, fight.w1 + 1);
    if (fight.w1 >= 2 || fight.w2 >= 2) { fight.matchOver = true; return; }
    fight.round++; fight.phase = 'between'; fight.phaseTimer = 60; resetPositions();
  }
}

function loop() {
  ctx.clearRect(0, 0, W, H);
  if (STATE === 'LOADING') stepLOADING();
  else if (STATE === 'TITLE') stepTITLE();
  else if (STATE === 'MODE') stepMODE();
  else if (STATE === 'SELECT') stepSELECT();
  else if (STATE === 'VERSUS') stepVERSUS();
  else if (STATE === 'FIGHT') stepFIGHT();
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
